#
# afx("basic_light") {
#   source = "a.afx"
#   # 实际上 afx 文件内部也提供文件名，此处之所以要制定，是为了能够统治
#   # gn 知道输出文件是什么，否则静态库的文件我们无法知晓
#   # 目前来看 afx 文件内的文件名是冗余的
#   # afx 模板目前仅仅用于开发实例，在实际过程中所有的 afx 都是已经开发好的
#   # 外部直接引用即可
#   filename = "$filename"
# }
#
#

template("afx") {
  assert(defined(invoker.source))
  afxc_path = "afxc.exe"
  if (!defined(invoker.filename)) {
    filename = target_name
  } else {
    filename = invoker.filename
  }

  hpp = "$filename" + ".afx.h"
  cpp = "$filename" + ".afx.cc"
  
  gen_dir = rebase_path(target_gen_dir, root_build_dir, ".")
  afx_file_path = rebase_path(invoker.source, root_build_dir)
  afxlib_path = rebase_path("//azer/azer/afx", root_build_dir)
  azer_root_path = rebase_path("//", root_build_dir)
  afx_args = [
    "$afxc_path",
    "--output_dir=" + rebase_path(target_gen_dir, root_build_dir),
    "--afx=$afx_file_path",
    "--hlslang",
    "--includes=$afxlib_path,$azer_root_path",
    "--cpp_filename=$filename",
  ]

  action(target_name+"_afx_cppcode") {
    exec_script("//azer/build/tools/shell/mkdir.py", [gen_dir])
    script = "//build/gn_run_binary.py"
    outputs = [
      "$target_gen_dir/$hpp",
      "$target_gen_dir/$cpp",
    ]

    args = afx_args  
    deps = ["//azer/afx:afxc"]
  }

  config("$target_name"+ "_config") {
    include_dirs = [target_gen_dir]
  }
  source_set(target_name) {
    # exec_script("//azer/build/tools/shell/mkdir.py", afx_args)
    sources = [
      "$target_gen_dir/$cpp",
      "$target_gen_dir/$hpp",
    ]
    direct_dependent_configs = [":$target_name" + "_config"]
    deps = [
      "//azer",
      "//azer/math",
      "//base",
      ":$target_name" + "_afx_cppcode",
    ]
    if (is_win) {
      cflags = ["/FI$hpp"]
    }
  }
}